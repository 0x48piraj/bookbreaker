import os
import pandas as pd
import chess
import chess.engine

# ───── CONFIG ─────
BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
CANDIDATES_CSV = os.path.join(BASE_DIR, "warehouse", "candidates", "cluster_analog_candidates.csv")
STOCKFISH_PATH = os.path.join(BASE_DIR, "stockfish", "stockfish-windows-x86-64-avx2.exe")

OUT_RANKED_CSV = os.path.join(BASE_DIR, "warehouse", "ranked", "ranked_candidates.csv")
DEPTH_SHALLOW = 8
DEPTH_DEEP = 24
TOP_N = 20

# ───── SCORE WEIGHTS ─────
ALPHA = 1.0    # Cluster distance (1 - dist)
BETA  = 1.5    # Shallow eval
GAMMA = 1.0    # Penalize deep eval
DELTA = 0.5    # Reward high branching
EPSILON = 1.0  # Trap gap (optional)
ZETA = 0.5     # Reward bold sacs — more dropped = better

# ───── LOAD CANDIDATES ─────
df = pd.read_csv(CANDIDATES_CSV)
os.makedirs(os.path.dirname(OUT_RANKED_CSV), exist_ok=True)

# ───── ENGINE SETUP ─────
engine = chess.engine.SimpleEngine.popen_uci(STOCKFISH_PATH)

scored_rows = []
for _, row in df.iterrows():
    uci_seq = row["moves_uci"].split()
    board = chess.Board()
    try:
        for uci in uci_seq:
            board.push_uci(uci)
    except Exception:
        continue

    # Dual-depth eval
    try:
        eval_shallow = engine.analyse(board, chess.engine.Limit(depth=DEPTH_SHALLOW))["score"].white().score(mate_score=10000) / 100.0
        eval_deep    = engine.analyse(board, chess.engine.Limit(depth=DEPTH_DEEP))["score"].white().score(mate_score=10000) / 100.0
    except:
        eval_shallow, eval_deep = 0.0, 0.0

    trap_gap = eval_shallow - eval_deep
    novelty_score = 1.0  # Placeholder

    # Composite score
    score = (
        ALPHA * (1 - row["distance"]) +
        BETA  * eval_shallow -
        GAMMA * abs(eval_deep) +
        DELTA * row["branching"] +
        EPSILON * trap_gap  +
        ZETA * abs(row["mat_imbalance"])
    )

    scored_rows.append({
        **row.to_dict(),
        "eval_shallow": eval_shallow,
        "eval_deep": eval_deep,
        "trap_gap": trap_gap,
        "score": score
    })

engine.quit()

# ───── EXPORT ─────
df_scored = pd.DataFrame(scored_rows)
df_scored = df_scored.sort_values("score", ascending=False)
df_scored.to_csv(OUT_RANKED_CSV, index=False)
print(f"[+] Ranked candidates written to {OUT_RANKED_CSV} (top score: {df_scored.iloc[0]['score']:.2f})")

# Save top-N to PGN
try:
    import chess.pgn
    OUT_PGN = OUT_RANKED_CSV.replace(".csv", ".pgn")
    with open(OUT_PGN, "w") as pgn_out:
        for _, row in df_scored.head(TOP_N).iterrows():
            game = chess.pgn.Game()
            board = chess.Board()
            node = game
            for uci in row["moves_uci"].split():
                move = board.push_uci(uci)
                node = node.add_variation(move)
                game.headers["Event"] = f"Cluster {row['cluster']} Candidate"
                game.headers["Site"] = "Generated by GambitGen"
                game.headers["Date"] = "????.??.??"
                game.headers["Round"] = "?"
                game.headers["White"] = "GambitGen"
                game.headers["Black"] = "Engine"
                game.headers["WhiteEval8"] = f"{row['eval_shallow']:.2f}"
                game.headers["WhiteEval24"] = f"{row['eval_deep']:.2f}"
                game.headers["TrapGap"] = f"{row['trap_gap']:.2f}"
                game.headers["Score"] = f"{row['score']:.2f}"
                game.headers["MaterialDrop"] = f"{abs(row['mat_imbalance']):.1f}"
                game.headers["Branching"] = f"{row['branching']}"
            print(game, file=pgn_out, end="\n\n")
    print(f"[+] Saved top {TOP_N} to PGN: {OUT_PGN}")
except ImportError:
    print("[!] chess.pgn not available — skipping PGN export")
